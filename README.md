# FoxSwift

> This file is generated by AI, please check the correctness of the content.

FoxSwift is a network application framework developed in Swift, focused on providing high-performance, type-safe, and easy-to-use API development experience. The project adopts a modular design, supports Swift Concurrency, and follows Protocol Oriented Programming principles.

## Project Structure

```tree
FoxSwift/
├── fox-swift-api/        # API core module
│   ├── Sources/
│   │   ├── APICore/      # Core API functionality
│   │   ├── APIPlugin/    # Plugin system
│   │   └── FoxSwiftAPI/  # Main API entry
├── fox-swift-server/     # Server implementation
└── References/           # Reference documents
```

## Key Features

### Currently Implemented

1. **WebSocket Support**
   - `WebSocketProvider` abstract interface, extensible to different WebSocket implementations
   - URLSession-based WebSocket implementation
   - Asynchronous support using Swift Concurrency
   - Type-safe message encoding and decoding
   - Complete connection lifecycle management

2. **Route Error Handling**
   - Standardized error response format
   - Custom error type support

### Technical Highlights

- Based on Swift 6.1+
- Supports macOS 15.0+
- Full adoption of Swift Concurrency
- Uses Protocol Oriented Programming
- Modular design
- Type-safe API
- Uses actor model for concurrency safety
- Uses SwiftLint to enforce code style consistency

## Usage Examples

### WebSocket Client

```swift
// Create WebSocket task
let url = URL(string: "wss://example.com/socket")!
let request = URLRequest(url: url)
let task = URLSession.shared.webSocketTask(with: request)

// Setup Provider
let provider = WebSocket.URLSessionProvider<MyMessage, MyCloseReason>(webSocketTask: task)

// Use WebSocket
try await provider.send(message: MyMessage(text: "Hello"))
let response = try await provider.receive()
print("Received message: \(response)")

// Close connection
try await provider.close(code: .normalClosure, reason: MyCloseReason(message: "Completed"))
```

## Technical Challenges and Implementation Details

### 1. Highly Abstracted WebSocket Interface

The most challenging part of the project is designing a highly abstracted and extensible WebSocket interface. This design allows:

- Users to easily switch between underlying implementations (URLSession, Vapor, etc.) without changing business logic
- Support for any custom message type and close reason through generics
- Provides a unified protocol interface, simplifying testing and simulation

```swift
// Highly abstracted Provider protocol
protocol Provider {
    associatedtype Message: MessageProtocol
    associatedtype CloseReason: Close.ReasonProtocol

    func ping() async throws
    func send(message: Message) async throws
    func receive() async throws -> Message
    func close(code: CloseCode, reason: CloseReason) async throws
    func awaitClosed() async throws -> Close.Info<CloseReason>
}
```

### 2. Swift Concurrency and Thread Safety

In the WebSocket implementation, a particularly tricky challenge is ensuring thread safety:

- Using the actor model to manage shared state, avoiding data races
- Carefully designing AsyncStream/AsyncChannel resource lifecycles
- Using capture lists to avoid circular references and memory leaks
- Properly handling asynchronous task cancellation and resource release

### 3. Swift Macro Application

This project uses Swift's macro system to simplify repetitive code:

- Automatically generating highly repetitive route handling code
- Using macros to handle error wrapping and conversion
- Simplifying API versioning and documentation generation
- Providing compile-time checks to ensure API endpoint consistency

### 4. Vapor Integration

The planned Vapor framework integration will face the following challenges:

- Maintaining consistency with existing abstraction layers
- Handling interoperability between Vapor and Swift Concurrency
- Implementing efficient request routing and middleware systems
- Ensuring consistency between server-side implementation and client-side user experience

### 5. Asynchronous Transformation of Delegate Pattern

An innovation point is converting the traditional delegate pattern to asynchronous event streams:

- Wrapping URLSessionWebSocketDelegate delegates into AsyncStream/AsyncChannel
- Managing different types of delegate events through enums
- Managing state within actors to ensure thread safety
- Providing intuitive event subscription and handling mechanisms

### 6. SwiftLint and Code Quality Management

The project uses SwiftLint to ensure code quality and consistency:

- Custom SwiftLint rule sets tailored to project-specific needs
- Enforcing naming conventions, file organization, and code style
- Limiting function complexity and length to promote maintainability
- Preventing common Swift programming errors and anti-patterns
- Integration into the build process to ensure all committed code meets standards

Through strict lint rules, we ensure:

- Improved code readability and consistency
- Reduced potential errors
- Simplified code review process
- Improved team collaboration efficiency

## To-Do List

1. **WebSocket Feature Enhancements**
   - [ ] Implement WebSocket reconnection mechanism
   - [ ] Add connection timeout handling
   - [ ] Add heartbeat mechanism
   - [ ] Develop Vapor-based WebSocket server implementation

2. **API Features**
   - [ ] Implement RESTful API client framework
   - [ ] Add request/response middleware system
   - [ ] Develop API versioning mechanism
   - [ ] Implement OAuth authentication

3. **Client-Side UI**

4. **Documentation and Testing**
   - [ ] Complete DocC documentation
   - [ ] Add unit tests
   - [ ] Add integration tests
   - [ ] Build example application

5. **Others**
   - [ ] Enhance error handling
   - [ ] Optimize Logger system
   - [ ] Deploy CI/CD workflow

## License
