# FoxSwift

> This file is generated by AI, please check the correctness of the content.

FoxSwift 是一個使用 Swift 語言開發的網路應用框架，專注於提供高性能、類型安全且易於使用的 API 開發體驗。專案採用模組化設計，支援 Swift Concurrency 並遵循 Protocol Oriented Programming 原則。

## 專案結構

```tree
FoxSwift/
├── fox-swift-api/        # API 核心模組
│   ├── Sources/
│   │   ├── APICore/      # 核心 API 功能
│   │   ├── APIPlugin/    # 插件系統
│   │   └── FoxSwiftAPI/  # 主要 API 入口
├── fox-swift-server/     # 伺服器實現
└── References/           # 參考文件
```

## 主要功能

### 目前已實現

1. **WebSocket 支援**
   - `WebSocketProvider` 抽象介面，可擴展至不同的 WebSocket 實現
   - 基於 `URLSession` 的 WebSocket 實現
   - 使用 Swift Concurrency 的非同步支援
   - 提供類型安全的訊息編碼與解碼
   - 完整的連接生命週期管理

2. **路由錯誤處理**
   - 標準化的錯誤回應格式
   - 自定義錯誤類型支援

### 技術特點

- 基於 Swift 6.1+
- 支援 macOS 15.0+
- 完全採用 Swift Concurrency
- 使用 Protocol Oriented Programming
- 模組化設計
- 類型安全 API
- 使用 actor 模型處理並發安全
- 使用 SwiftLint 強制程式碼風格一致性

## 使用範例

### WebSocket 客戶端

```swift
// 創建 WebSocket 任務
let url = URL(string: "wss://example.com/socket")!
let request = URLRequest(url: url)
let task = URLSession.shared.webSocketTask(with: request)

// 設置 Provider
let provider = WebSocket.URLSessionProvider<MyMessage, MyCloseReason>(webSocketTask: task)

// 使用 WebSocket
try await provider.send(message: MyMessage(text: "Hello"))
let response = try await provider.receive()
print("收到訊息：\(response)")

// 關閉連接
try await provider.close(code: .normalClosure, reason: MyCloseReason(message: "完成"))
```

## 技術挑戰與實現細節

### 1. 高度抽象化的 WebSocket 介面

專案中最具挑戰性的部分是設計了高度抽象且可擴展的 WebSocket 介面。這種設計使得：

- 使用者可以輕鬆切換底層實現（URLSession、Vapor 等），而不改變上層業務邏輯
- 通過泛型支持任意自定義訊息類型和關閉原因
- 提供統一的協議介面，簡化測試和模擬

```swift
// 高度抽象的 Provider 協議
protocol Provider {
    associatedtype Message: MessageProtocol
    associatedtype CloseReason: Close.ReasonProtocol

    func ping() async throws
    func send(message: Message) async throws
    func receive() async throws -> Message
    func close(code: CloseCode, reason: CloseReason) async throws
    func awaitClosed() async throws -> Close.Info<CloseReason>
}
```

### 2. Swift Concurrency 與並發安全

在 WebSocket 實現中，一個特別棘手的挑戰是確保並發安全：

- 使用 actor 模型管理共享狀態，避免資料競爭
- 精心設計 AsyncStream/AsyncChannel 的資源生命週期
- 使用捕獲列表避免循環引用和內存泄漏
- 正確處理非同步任務的取消和資源釋放

### 3. Swift Macro 的應用

本專案使用了 Swift 的宏系統來簡化重複程式碼：

- 自動生成重複性強的路由處理程式碼
- 使用宏處理錯誤包裝和轉換
- 簡化 API 的版本控制和文檔生成
- 提供編譯期檢查，確保 API 端點的一致性

### 4. Vapor 整合

計劃中的 Vapor 框架整合將面臨以下挑戰：

- 保持與現有抽象層的一致性
- 處理 Vapor 與 Swift Concurrency 的互操作
- 實現高效的請求路由和中間件系統
- 確保伺服器端實現與客戶端使用體驗的一致性

### 5. 委派模式的非同步轉換

一個創新點是將傳統的委派模式轉換為非同步事件流：

- 將 URLSessionWebSocketDelegate 委派封裝到 AsyncStream/AsyncChannel
- 通過 enum 統一管理不同類型的委派事件
- 在 actor 內部管理狀態，確保線程安全
- 提供直觀的事件訂閱和處理機制

### 6. SwiftLint 與程式碼品質管理

專案採用 SwiftLint 工具來確保程式碼品質和一致性：

- 自定義 SwiftLint 規則集，符合專案特定需求
- 強制執行命名規範、檔案組織和程式碼風格
- 限制函數複雜度和長度，促進可維護性
- 預防常見的 Swift 程式設計錯誤和反模式
- 集成到建構過程，確保所有提交的程式碼符合標準

通過嚴格的 lint 規則，我們確保：

- 提高程式碼可讀性和一致性
- 減少潛在錯誤
- 簡化程式碼審查流程
- 提高團隊協作效率

## 待辦事項

1. **WebSocket 功能增強**
   - [ ] 實現 WebSocket 重連機制
   - [ ] 添加連接超時處理
   - [ ] 添加心跳機制
   - [ ] 開發基於 Vapor 的 WebSocket 服務端實現

2. **API 功能**
   - [ ] 實現 RESTful API 客戶端框架
   - [ ] 添加請求/回應中間件系統
   - [ ] 開發 API 版本控制機制
   - [ ] 實現 OAuth 身份驗證

3. **Client 端 UI**

4. **文件與測試**
   - [ ] 完善 DocC 文件
   - [ ] 添加單元測試
   - [ ] 添加整合測試
   - [ ] 建立示例應用

5. **其他**
   - [ ] 完善錯誤處理
   - [ ] 優化 Logger 系統
   - [ ] 部署 CI/CD 流程

## 授權
