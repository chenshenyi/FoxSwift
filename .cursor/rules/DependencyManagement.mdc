---
description: 
globs: 
alwaysApply: true
---
# Dependency Management Guidelines

## Package Manager

### Swift Package Manager

- Prioritize using Swift Package Manager
- Explicitly specify package versions
- Use semantic versioning
- Regularly update dependencies

### Version Control

```swift
// Package.swift
dependencies: [
    .package(url: "https://github.com/apple/swift-nio.git", from: "2.0.0"),
    .package(url: "https://github.com/apple/swift-log.git", "1.0.0"..<"2.0.0"),
    .package(url: "https://github.com/vapor/vapor.git", exact: "4.0.0")
]
```

## Version Management

### Version Standards

- Follow Semantic Versioning (SemVer)
- Major version: Incompatible API changes
- Minor version: Backward-compatible feature additions
- Patch version: Backward-compatible bug fixes

### Version Pinning

- Use version ranges
- Avoid using latest version (.upToNextMajor)
- Lock specific versions when necessary
- Document reasons for version updates

## Modular Design

### Module Principles

- High cohesion, low coupling
- Clear module boundaries
- Minimize public APIs
- Avoid circular dependencies

### Module Structure

```swift
// Module definition
public protocol NetworkingModule {
    func configure()
    func start() async throws
    func stop() async
}

// Dependency injection
public struct AppModules {
    let networking: NetworkingModule
    let storage: StorageModule
    let auth: AuthModule
    
    public init(
        networking: NetworkingModule,
        storage: StorageModule,
        auth: AuthModule
    ) {
        self.networking = networking
        self.storage = storage
        self.auth = auth
    }
}
```

## Dependency Injection

### Injection Methods

- Constructor injection
- Property injection
- Method injection
- Interface injection

### Injection Example

```swift
protocol DataFetching {
    func fetch() async throws -> Data
}

class NetworkService {
    private let fetcher: DataFetching
    
    init(fetcher: DataFetching) {
        self.fetcher = fetcher
    }
}
```
